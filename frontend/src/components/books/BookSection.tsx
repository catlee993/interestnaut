import React, {
  forwardRef,
  useImperativeHandle,
  useCallback,
  useRef,
} from "react";
import { Box, Card, CardMedia } from "@mui/material";
import { BookCard } from "./BookCard";
// Since @wailsjs/go/bindings/Books might not exist yet, we're defining expected function interfaces
// These will be generated when the app is built with Wails
// The actual implementations will be automatically generated by Wails
// based on the Go bindings we've created
interface BooksAPI {
  SearchBooks: (query: string) => Promise<BookWithSavedStatus[]>;
  SetFavoriteBooks: (books: any[]) => Promise<void>;
  GetFavoriteBooks: () => Promise<any[]>;
  GetBookSuggestion: () => Promise<BookSuggestion>;
  GetBookDetails: (key: string) => Promise<BookWithSavedStatus>;
  ProvideSuggestionFeedback: (
    outcome: string,
    title: string,
    author: string,
  ) => Promise<void>;
  AddToReadList: (book: any) => Promise<void>;
  GetReadList: () => Promise<any[]>;
  RemoveFromReadList: (title: string, author: string) => Promise<void>;
}

// Declare the types we expect to be generated
interface BookWithSavedStatus {
  title: string;
  author: string;
  key: string;
  cover_path: string;
  year?: number;
  subjects?: string[];
  isSaved?: boolean;
}

interface BookSuggestion {
  title: string;
  author: string;
  cover_path: string;
  key?: string;
  reasoning: string;
  primary_genre: string;
}

// Mock the Go bindings for development
// These will be replaced by the actual generated bindings when built with Wails
const Books: BooksAPI = {
  SearchBooks: async () => [],
  SetFavoriteBooks: async () => {},
  GetFavoriteBooks: async () => [],
  GetBookSuggestion: async () => ({
    title: "",
    author: "",
    cover_path: "",
    reasoning: "",
    primary_genre: "",
  }),
  GetBookDetails: async () => ({
    title: "",
    author: "",
    key: "",
    cover_path: "",
  }),
  ProvideSuggestionFeedback: async () => {},
  AddToReadList: async () => {},
  GetReadList: async () => [],
  RemoveFromReadList: async () => {},
};

// Try to import the actual bindings if available at build time
try {
  const BooksModule = require("@wailsjs/go/bindings/Books");
  Object.assign(Books, BooksModule);
} catch (error) {
  console.warn("Books bindings not found, using mock implementation");
}

import { MediaSuggestionItem } from "@/components/common/MediaSuggestionDisplay";
import { useMediaSection, MediaItemBase } from "@/hooks/useMediaSection";
import {
  MediaSectionLayout,
  MediaGrid,
} from "@/components/common/MediaSectionLayout";
import { MediaItemWrapper } from "@/components/common/MediaItemWrapper";
import { session } from "@wailsjs/go/models";

// Define the exported types
export interface BookSectionHandle {
  handleClearSearch: () => void;
  handleSearch: (query: string) => Promise<void>;
}

// Define our own type that combines both interfaces
interface BookItem extends BookWithSavedStatus {
  id: number; // Using the generated numeric ID
  isSaved?: boolean;
  isInWatchlist?: boolean;
}

export const BookSection = forwardRef<BookSectionHandle, {}>((props, ref) => {
  const searchResultsRef = useRef<HTMLDivElement>(null);

  // Create a unique ID for each book based on title and author
  const generateId = (book: BookWithSavedStatus): number => {
    const str = `${book.title}-${book.author}`;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  };

  // Convert BookWithSavedStatus to a MediaItemBase-compatible object
  const bookToMediaItem = useCallback((book: BookWithSavedStatus): any => {
    return {
      id: generateId(book),
      title: book.title,
      name: book.author, // Store author in name
      // We'll use these for UI rendering
      _author: book.author,
      _coverPath: book.cover_path,
      _key: book.key || `${book.title}-${book.author}`,
      _year: book.year,
      _subjects: book.subjects,
      isSaved: book.isSaved,
    };
  }, []);

  // Convert MediaItemBase back to BookWithSavedStatus
  const mediaItemToBook = useCallback((item: any): BookWithSavedStatus => {
    return {
      title: item.title,
      author: item._author || item.name,
      key: item._key || "",
      cover_path: item._coverPath || "",
      year: item._year,
      subjects: item._subjects,
      isSaved: item.isSaved,
    };
  }, []);

  // Use the media section hook with necessary type assertions
  const mediaSection = useMediaSection({
    // @ts-ignore - allow book as a type
    type: "book",

    checkCredentials: async () => true,

    getSuggestion: async () => {
      const suggestion = await Books.GetBookSuggestion();

      const book: BookWithSavedStatus = {
        title: suggestion.title,
        author: suggestion.author,
        key: suggestion.key || `${suggestion.title}-${suggestion.author}`,
        cover_path: suggestion.cover_path || "",
      };

      return {
        // @ts-ignore
        media: bookToMediaItem(book),
        reason: suggestion.reasoning,
      };
    },

    provideFeedback: async (outcome, id) => {
      // Find book in current data and provide feedback
      // @ts-ignore
      const currentBook = mediaSection.suggestedItem
        ? mediaItemToBook(mediaSection.suggestedItem)
        : null;

      if (currentBook) {
        await Books.ProvideSuggestionFeedback(
          outcome,
          currentBook.title,
          currentBook.author,
        );
      }
    },

    loadSavedItems: async () => {
      const favoriteBooks = await Books.GetFavoriteBooks();
      return favoriteBooks.map((book) => ({
        ...bookToMediaItem(book),
        isSaved: true,
      }));
    },

    loadWatchlistItems: async () => {
      const readList = await Books.GetReadList();
      return readList.map(bookToMediaItem);
    },

    searchItems: async (query: string) => {
      const results = await Books.SearchBooks(query);

      // Add isSaved flag based on favorites
      const favoriteBooks = await Books.GetFavoriteBooks();

      return results.map((book) => {
        const isSaved = favoriteBooks.some(
          (fav) => fav.title === book.title && fav.author === book.author,
        );
        return bookToMediaItem({ ...book, isSaved });
      });
    },

    saveItem: async (item) => {
      const book = mediaItemToBook(item);
      const favoriteBooks = await Books.GetFavoriteBooks();

      if (item.isSaved) {
        // Remove from favorites
        const updatedFavorites = favoriteBooks.filter(
          (fav) => fav.title !== book.title || fav.author !== book.author,
        );
        await Books.SetFavoriteBooks(updatedFavorites);
      } else {
        // Add to favorites
        await Books.SetFavoriteBooks([...favoriteBooks, book]);
      }
    },

    removeItem: async (item) => {
      const book = mediaItemToBook(item);
      const favoriteBooks = await Books.GetFavoriteBooks();

      const updatedFavorites = favoriteBooks.filter(
        (fav) => fav.title !== book.title || fav.author !== book.author,
      );
      await Books.SetFavoriteBooks(updatedFavorites);
    },

    addToWatchlist: async (item) => {
      const book = mediaItemToBook(item);
      await Books.AddToReadList(book);
    },

    removeFromWatchlist: async (item) => {
      const book = mediaItemToBook(item);
      await Books.RemoveFromReadList(book.title, book.author);
    },

    getItemDetails: async (id) => {
      // In a real implementation, we'd need to map the numeric ID back to a string key
      // For now, just assume we can use the ID directly
      const details = await Books.GetBookDetails("");
      return bookToMediaItem(details);
    },

    // Local storage and UI settings
    cachedSuggestionKey: "cached_book_suggestion",
    cachedReasonKey: "cached_book_reason",
    queueListName: "Read List",
  });

  // Expose functions via ref
  useImperativeHandle(ref, () => ({
    handleClearSearch: mediaSection.handleClearSearch,
    handleSearch: mediaSection.handleSearch,
  }));

  // Convert to MediaSuggestionItem for displaying
  const mapBookToSuggestionItem = useCallback(
    (item: any): MediaSuggestionItem => {
      const book = mediaItemToBook(item);
      return {
        id: item.id,
        title: book.title,
        description: `by ${book.author}`,
        imageUrl: book.cover_path || undefined,
      };
    },
    [mediaItemToBook],
  );

  // Custom renderer for book cover
  const renderBookCover = useCallback(
    (item: MediaSuggestionItem) => {
      if (!item.imageUrl) return null;

      return (
        <Card sx={{ height: "100%" }}>
          <CardMedia
            component="img"
            image={item.imageUrl}
            alt={item.title}
            sx={{
              height: "450px",
              objectFit: "cover",
              opacity: mediaSection.isProcessingFeedback ? 0.5 : 1,
              transition: "all 0.2s ease-in-out",
            }}
          />
        </Card>
      );
    },
    [mediaSection.isProcessingFeedback],
  );

  // Render functions for the sections using our converters
  const renderSearchResults = useCallback(
    () => (
      <MediaGrid>
        {mediaSection.searchResults.map((item: any) => {
          const book = mediaItemToBook(item);
          return (
            <Box
              key={`search-${book.key || book.title}`}
              sx={{ cursor: "pointer" }}
            >
              <BookCard
                book={book}
                isSaved={!!item.isSaved}
                isInReadList={mediaSection.watchlistItems.some(
                  (b: any) =>
                    mediaItemToBook(b).title === book.title &&
                    mediaItemToBook(b).author === book.author,
                )}
                view="default"
                onSave={() => mediaSection.handleSave(item)}
                onAddToReadList={() => mediaSection.handleAddToWatchlist(item)}
              />
            </Box>
          );
        })}
      </MediaGrid>
    ),
    [
      mediaSection.searchResults,
      mediaSection.watchlistItems,
      mediaSection.handleSave,
      mediaSection.handleAddToWatchlist,
      mediaItemToBook,
    ],
  );

  const renderWatchlistItems = useCallback(
    () => (
      <MediaGrid>
        {mediaSection.watchlistItems.map((item: any) => {
          const book = mediaItemToBook(item);
          return (
            <MediaItemWrapper
              key={`readlist-${book.key || book.title}`}
              item={item}
              view="watchlist"
              onRemoveFromWatchlist={() =>
                mediaSection.handleRemoveFromWatchlist(item)
              }
            >
              <BookCard
                book={book}
                isSaved={!!item.isSaved}
                view="readlist"
                onSave={() => mediaSection.handleWatchlistToFavorites(item)}
                onRemoveFromReadList={undefined}
                onLike={() =>
                  mediaSection.handleWatchlistFeedback(item, "like")
                }
                onDislike={() => {
                  mediaSection.handleWatchlistFeedback(item, "dislike");
                  mediaSection.handleRemoveFromWatchlist(item);
                }}
              />
            </MediaItemWrapper>
          );
        })}
      </MediaGrid>
    ),
    [
      mediaSection.watchlistItems,
      mediaSection.handleWatchlistToFavorites,
      mediaSection.handleWatchlistFeedback,
      mediaSection.handleRemoveFromWatchlist,
      mediaItemToBook,
    ],
  );

  const renderSavedItems = useCallback(
    () => (
      <MediaGrid>
        {mediaSection.savedItems.map((item: any) => {
          const book = mediaItemToBook(item);
          return (
            <MediaItemWrapper
              key={`saved-${book.key || book.title}`}
              item={item}
              view="saved"
              onRemoveFromWatchlist={() => mediaSection.handleSave(item)}
            >
              <BookCard
                book={book}
                isSaved={true}
                isInReadList={mediaSection.watchlistItems.some(
                  (b: any) =>
                    mediaItemToBook(b).title === book.title &&
                    mediaItemToBook(b).author === book.author,
                )}
                view="default"
                onSave={() => mediaSection.handleSave(item)}
                onAddToReadList={() => mediaSection.handleAddToWatchlist(item)}
              />
            </MediaItemWrapper>
          );
        })}
      </MediaGrid>
    ),
    [
      mediaSection.savedItems,
      mediaSection.watchlistItems,
      mediaSection.handleSave,
      mediaSection.handleAddToWatchlist,
      mediaItemToBook,
    ],
  );

  return (
    <MediaSectionLayout
      // Type metadata
      type="book"
      typeName="Book"
      // Refs
      searchResultsRef={searchResultsRef}
      // State
      credentialsError={mediaSection.credentialsError}
      isLoadingSuggestion={mediaSection.isLoadingSuggestion}
      suggestionError={mediaSection.suggestionError}
      isProcessingFeedback={mediaSection.isProcessingFeedback}
      searchResults={mediaSection.searchResults}
      showSearchResults={mediaSection.showSearchResults}
      watchlistItems={mediaSection.watchlistItems}
      savedItems={mediaSection.savedItems}
      showWatchlist={mediaSection.showWatchlist}
      showLibrary={mediaSection.showLibrary}
      // Suggestion data
      suggestedItem={mediaSection.suggestedItem}
      suggestionReason={mediaSection.suggestionReason}
      // Event handlers
      onRefreshCredentials={() => {}} // No credentials needed for books
      onRequestSuggestion={mediaSection.handleGetSuggestion}
      onLikeSuggestion={() => 
        mediaSection.handleFeedback && mediaSection.handleFeedback(session.Outcome.liked)}
      onDislikeSuggestion={() => 
        mediaSection.handleFeedback && mediaSection.handleFeedback(session.Outcome.disliked)}
      onSkipSuggestion={() => 
        mediaSection.handleFeedback && mediaSection.handleFeedback(session.Outcome.skipped)}
      onAddToLibrary={() => 
        mediaSection.suggestedItem && mediaSection.handleSave(mediaSection.suggestedItem)}
      onAddSuggestionToWatchlist={() => 
        mediaSection.suggestedItem && mediaSection.handleAddToWatchlist(mediaSection.suggestedItem)}
      onToggleWatchlist={() =>
        mediaSection.setShowWatchlist(!mediaSection.showWatchlist)
      }
      onToggleLibrary={() =>
        mediaSection.setShowLibrary(!mediaSection.showLibrary)
      }
      // Render functions
      renderSearchResults={renderSearchResults}
      renderWatchlistItems={renderWatchlistItems}
      renderSavedItems={renderSavedItems}
      renderSuggestionPoster={renderBookCover}
      // Mapping function
      mapToSuggestionItem={mapBookToSuggestionItem}
      queueName="Read List"
    />
  );
});
